C     ANDREW SPATE, ANDREW BISSELL, JUSTIN GUNDERSON
C     GROUP 2 
C     FORTRAN 306
C     GRAPHER
!------------------------------------------------------------------------
!************************************************************************

      MODULE IO_FILE
      IMPLICIT NONE
      INTEGER :: STATUS
      !INTEGER :: NUMPOINTS
      INTEGER :: LOOPCOUNT
      INTEGER :: I
      INTEGER :: J
      INTEGER :: X=1
      INTEGER :: Y=2
      !REAL, DIMENSION(100,3) :: POINTS
      !REAL ::POINTS
      
      
      LOGICAL :: EXISTS
      LOGICAL :: FILES_OPEN
      LOGICAL :: FLAG1
      LOGICAL :: FLAG2
      LOGICAL :: FLAG3
      
      CHARACTER(LEN=20) :: INFILE_NAME
      CHARACTER(LEN=20) :: OUTFILE_NAME
      CHARACTER(LEN=20) :: TEMP_NAME
      CHARACTER(LEN=80) :: LINE

      
      CONTAINS
!------------------------------------------------------------------------ 
C OPEN_MASTER SUBROUTINE
C BY ANDREW SPATE, JUSTIN GUNDERSON, ANDREW BISSELL
C GENERAL: MASTER SUBROUTINE FOR OPENING INPUT FILE AND CREATING AN OUTPUT FILE
C PRECONDITIONS: A CORRECT INPUT FILE 
C POSTCONDITIONS: CHECKS INPUT FILE AND CREATES OR OVERRIDES AN OUTPUT FILE
C WRITTEN 10/02/2021
!------------------------------------------------------------------------
      SUBROUTINE OPEN_MASTER(POINTS, NUMPOINTS, ALARMSIREN,BADDATA,
     +HEADACHE)
      INTEGER,INTENT(OUT):: NUMPOINTS
      REAL, INTENT(OUT), DIMENSION(100,3)::POINTS
      LOGICAL, INTENT(OUT) :: ALARMSIREN
      LOGICAL, INTENT(OUT) :: BADDATA
      LOGICAL, INTENT(OUT) :: HEADACHE
      
C     Prompt for, test existence of INPUT FILE NAME
      CALL INPUTFILE()
C     If the file exists, prompt the user to enter a new file name, overwrite the existing file, or 'QUIT',otherwise open the new file.
      IF(FLAG1 .EQV. .TRUE.) THEN
      CALL OUTPUTFILE()
      END IF      
C     OPEN BOTH FILES WITH FLAG
      IF ((FLAG1 .EQV. .TRUE.) .AND. (FLAG2 .EQV. .TRUE.)) THEN
      OPEN(UNIT=1, FILE=INFILE_NAME, STATUS='OLD',IOSTAT=STATUS)
      IF (STATUS .EQ.0) THEN
      OPEN(UNIT=2, FILE=OUTFILE_NAME, STATUS='REPLACE', IOSTAT=STATUS)
      IF (STATUS .EQ. 0) THEN
      FILES_OPEN=.TRUE.
      END IF
      END IF
      END IF
      IF (FILES_OPEN)THEN
      CALL READ_THE_FILE(POINTS, NUMPOINTS, BADDATA, HEADACHE)
      ELSE 
      ALARMSIREN=.FALSE.
      END IF
      END SUBROUTINE
      
      
!-----------------------------------------------------------------------------
C INPUTFILE SUBROUTINE
C BY ANDREW SPATE, JUSTIN GUNDERSON, ANDREW BISSELL AND DR PYZDROWSKI
C GENERAL: PROMPTS FOR INPPUT FILE FROM USER
C PRECONDITIONS: NONE
C POSTCONDITIONS: RETURNS FILE NAME, AND EXISTING STATUS AS FLAG
C WRITTEN: 9/23
!-----------------------------------------------------------------------------
      SUBROUTINE INPUTFILE()
C      CHARACTER(LEN=20) :: INFILE_NAME
C      LOGICAL, INTENT(OUT):: EXISTS, FLAG1
      WRITE(*,*)'ENTER INPUT FILE NAME (INCLUDING FILE EXTENSION)'
      READ(*,'(A)')INFILE_NAME 
      INQUIRE(FILE=INFILE_NAME,EXIST=EXISTS)
      
      IF (EXISTS)THEN
      FLAG1=.TRUE.
      END IF
C     IF FILE IS FALSE, THEN LOOP FOR CONTINUE
      DO WHILE ((FLAG1 .EQV. .FALSE.) .AND. (TRIM(INFILE_NAME) 
     +.NE. "QUIT"))
      WRITE(*,*)'ENTER INPUT FILE NAME OR QUIT TO QUIT'
      READ(*,'(A)')INFILE_NAME 
      INQUIRE(FILE=INFILE_NAME,EXIST=EXISTS)
      IF (EXISTS) THEN
      FLAG1=.TRUE.
      END IF
      END DO
      IF (EXISTS) THEN
      FLAG1=.TRUE.
      END IF   
      END SUBROUTINE INPUTFILE   

!-------------------------------------------------------------------------
C OUTPUTFILE SUBROUTINE
C BY ANDREW SPATE, JUSTIN GUNDERSON, ANDREW BISSELL AND DR PYZDROWSKI
C GENERAL: PROMPTS FOR OUTPUT FILE FROM USER
C PRECONDITIONS: NONE
C POSTCONDITIONS: RETURNS FILE NAME, AND EXISTING STATUS AS FLAG
C WRITTEN: 9/23
!-------------------------------------------------------------------------
      SUBROUTINE OUTPUTFILE()
      WRITE(*,*)'ENTER OUTPUT FILE NAME (INCLUDING FILE EXTENSION)'
      READ(*,'(A)')OUTFILE_NAME
      INQUIRE(FILE=OUTFILE_NAME,EXIST=EXISTS)
      IF (EXISTS) THEN
      FLAG2=.FALSE.
      ELSE
      FLAG2=.TRUE.
      END IF
      TEMP_NAME=OUTFILE_NAME
      DO WHILE (FLAG2 .EQV. .FALSE. .AND.(TRIM(OUTFILE_NAME) 
     +.EQ. "QUIT"))
      WRITE(*,*)"YOU ENTERED A USED FILE NAME, ENTER A NEW FILENAME OR
     +OVERWRITE (TO OVERWRITE THE FILE) OR QUIT"
      READ(*,'(A)')OUTFILE_NAME
C     SELECT CASE TO DETERMINE WHAT USER WANTS TO DO NEXT IF BAD OUTPUT FILE GIVEN
      SELECT CASE (TRIM(OUTFILE_NAME))
      CASE("QUIT")
      FLAG2=.FALSE.
      CASE("OVERWRITE")
      OUTFILE_NAME=TEMP_NAME
      FLAG2=.TRUE.
      CASE DEFAULT 
      INQUIRE(FILE=OUTFILE_NAME, EXIST=EXISTS)
      IF (EXISTS) THEN
      FLAG2=.TRUE.
      END IF 
      END SELECT 
C     END DO FROM RE-ENTER OUTPUTFILE NAME TRUE
      END DO
      
      END SUBROUTINE OUTPUTFILE
      
!------------------------------------------------------------------------ 
C READ_THE_FILE SUBROUTINE
C BY ANDREW SPATE, JUSTIN GUNDERSON, ANDREW BISSELL
C GENERAL: READS CONTENTS OF THE INPUT FILE INTO AN ARRAY
C PRECONDITIONS: NEED A CORRECTLY OPENED INPUT FILE
C POSTCONDITIONS: FILLS THE POINTS ARRAY WITH THE INPUT FILE DATA
C WRITTEN 10/02/2021
!------------------------------------------------------------------------
      SUBROUTINE READ_THE_FILE(POINTS, NUMPOINTS, BADDATA, HEADACHE)
      INTEGER, INTENT (OUT):: NUMPOINTS
      REAL, INTENT(OUT), DIMENSION(100,3):: POINTS
      LOGICAL, INTENT(OUT) :: BADDATA
      LOGICAL, INTENT(OUT) :: HEADACHE
      
      IF (FILES_OPEN .EQV. .TRUE.) THEN
10    FORMAT(I3)
      READ(1,*,IOSTAT=STATUS)NUMPOINTS
      I=1
      DO WHILE(I .LE. NUMPOINTS)
      READ(1,*, IOSTAT=STATUS)POINTS(I,1), POINTS(I,2)
      IF (STATUS .EQ. -1) THEN
      BADDATA= .TRUE.
      END IF
      I=I+1  
      END DO
      END IF
      READ(1,*,IOSTAT=STATUS)
      IF (STATUS .NE. -1) THEN
      HEADACHE = .TRUE.
      END IF
      END SUBROUTINE
!------------------------------------------------------------------------


      END MODULE
!************************************************************************


      MODULE GRAPHER
      INTEGER :: ENDPOINT
      INTEGER :: I
      REAL :: XLABELINC
      REAL :: YMIN, YMAX, XMIN, XMAX
      REAL :: YSTEP, XSTEP, DELTAX
      REAL, DIMENSION(3) :: SEARCHFIND
      INTEGER :: FOUNDINDEX
      LOGICAL :: FOUNDFLAG
      LOGICAL :: MORE
      LOGICAL :: DELTAXFLAG
      REAL, DIMENSION(1,2)::TEMP
      REAL, DIMENSION(6) :: YLABEL
      REAL, DIMENSION(200) :: XLABEL
      INTEGER :: P
      INTEGER :: YP
      INTEGER :: LABELLOOP
      
      CONTAINS
!------------------------------------------------------------------------ 
C GRAPHER_MASTER SUBROUTINE
C BY ANDREW SPATE, JUSTIN GUNDERSON, ANDREW BISSELL
C GENERAL: MASTER CONTROL SUBROUTINE FOR THE GRAPHER MODULE
C PRECONDITIONS: SUBROUTINES SORTER, PRINTARRAY, MINMAX, DELTAXFINDER, STAIRMASTER, LABELMAKER AND GRAPHMAPPER
C                MUST BE SET UP FOR USE
C POSTCONDITIONS: TAKES GIVEN DATA FROM INPUT FILE AND GRAPHS DATA TO OUTPUT FILE
C WRITTEN 10/22/2021
!------------------------------------------------------------------------      
      SUBROUTINE GRAPHER_MASTER(POINTS, NUMPOINTS)
      REAL, INTENT(OUT), DIMENSION(100,3)::POINTS
      INTEGER, INTENT(OUT) :: NUMPOINTS
      
      CALL SORTER(POINTS, NUMPOINTS)
      WRITE(2,*)"SORTED DATA POINTS"
      CALL PRINTARRAY(POINTS, NUMPOINTS, 2)
      CALL MINMAX(POINTS, NUMPOINTS)
      DELTAXFLAG= .FALSE.
      CALL DELTAXFINDER(POINTS, NUMPOINTS)
      CALL STAIRMASTER(POINTS, NUMPOINTS)
      
67    FORMAT(' ',2(A, F11.5, 3X))  
      WRITE(2,67)"YMAX:  ",YMAX,"YMIN:  ",YMIN
      WRITE(2,67)"XMAX:  ",XMAX,"XMIN:  ",XMIN
      WRITE(2,67)"YSTEP: ", YSTEP,"XSTEP: ", XSTEP
      WRITE(2,67)"DELTAX:", DELTAX
      
      CALL LABELMAKER()
      CALL GRAPHMAPPER(POINTS, NUMPOINTS) 
      
      END SUBROUTINE GRAPHER_MASTER
      
!------------------------------------------------------------------------ 
C SORTER SUBROUTINE
C BY ANDREW SPATE & ANDREW BISSELL
C GENERAL: TAKES DATA AND SORTS IT INTO LEAST TO GREATEST VALUE IN AN ARRAY
C PRECONDITIONS: N/A
C POSTCONDITIONS: SORTS DATA IN AN ARRAY FROM LEAST TO GREATEST
C WRITTEN 10/15/2021
!------------------------------------------------------------------------
      SUBROUTINE SORTER(POINTS, NUMPOINTS)
      REAL, INTENT(OUT), DIMENSION(100,3)::POINTS
      INTEGER, INTENT(OUT) :: NUMPOINTS      
      I=1
      ENDPOINT=NUMPOINTS-1
      MORE= .TRUE.
      DO WHILE(MORE)
      MORE=.FALSE.
      DO I=1, ENDPOINT
      IF (POINTS(I,1) .GT. POINTS((I+1),1)) THEN
      MORE=.TRUE.
      TEMP(1,1)=POINTS(I,1)
      TEMP(1,2)=POINTS(I,2)
      POINTS(I,1)=POINTS((I+1),1)
      POINTS(I,2)=POINTS((I+1),2)
      POINTS((I+1),1)=TEMP(1,1)
      POINTS((I+1),2)=TEMP(1,2)
      ENDIF  
      END DO
      ENDPOINT=ENDPOINT-1
      END DO
      END SUBROUTINE
      
!------------------------------------------------------------------------ 
C MINMAX SUBROUTINE
C BY ANDREW SPATE & ANDREW BISSELL
C GENERAL: LOCATES THE MIN AND MAX FOR X AND Y
C PRECONDITIONS: N/A
C POSTCONDITIONS: FROM GIVEN DATA GETS THE MIN AND MAX VALUES FOR BOTH THE X AND Y DATA.
C WRITTEN 10/15/2021
!------------------------------------------------------------------------
      SUBROUTINE MINMAX(POINTS, NUMPOINTS)
      REAL, INTENT(IN), DIMENSION(100,3):: POINTS
      INTEGER, INTENT(OUT) :: NUMPOINTS
      
      XMIN= POINTS(1,1)
      XMAX= POINTS(NUMPOINTS, 1)
      YMIN= POINTS(1,2)
      YMAX= POINTS(1,2)
      DO I=1, NUMPOINTS
      IF (POINTS(I,2) .LT. YMIN) THEN
      YMIN=POINTS(I,2)
      END IF 
      IF (POINTS(I,2) .GT. YMAX) THEN
      YMAX=POINTS(I,2)
      END IF
      END DO
      END SUBROUTINE
            
!------------------------------------------------------------------------ 
C STAIRMASTER SUBROUTINE
C BY ANDREW SPATE & ANDREW BISSELL
C GENERAL: GETS RANGE FOR X AND Y AXIS AND NUMBER OF STEPS NEEDED TO PROPERLY DISPLAY POINTS ON X AXIS
C PRECONDITIONS: N/A
C POSTCONDITIONS: SETS THE RANGE FOR POINTS IF TO FEW OR TO MANY THE RANGE IS FORCED
C WRITTEN 10/17/2021
!------------------------------------------------------------------------
      SUBROUTINE STAIRMASTER(POINTS, NUMPOINTS)
      REAL, INTENT(IN), DIMENSION(100,3):: POINTS
      INTEGER, INTENT(IN):: NUMPOINTS
      
      
      YSTEP=(YMAX-YMIN)/6   
      XSTEP=INT(((XMAX-XMIN)/DELTAX)+1)
      IF (XSTEP .LT. 20) THEN
      XSTEP = 20
      DELTAXFLAG= .TRUE.
      CALL DELTAXFINDER(POINTS, NUMPOINTS)
      ELSE IF (XSTEP .GT. 200) THEN
      XSTEP=200
      DELTAXFLAG= .TRUE.
      CALL DELTAXFINDER(POINTS, NUMPOINTS)
      END IF
      END SUBROUTINE
      
!------------------------------------------------------------------------ 
C DELTAXFINDER SUBROUTINE
C BY ANDREW SPATE & ANDREW BISSELL
C GENERAL: FINDS THE SMALLEST CHANGE IN X
C PRECONDITIONS: N/A
C POSTCONDITIONS: CHECKS DELTAX FOR THE SMALLEST CHANGE BETWEEN X POINTS AND SETS IT TO DELTAX 
C WRITTEN 10/17/2021
!------------------------------------------------------------------------
      SUBROUTINE DELTAXFINDER(POINTS, NUMPOINTS)
      REAL, INTENT(IN), DIMENSION(100,3) :: POINTS
      INTEGER, INTENT(IN):: NUMPOINTS 
      DELTAX=0
      I=1
      !WRITE(*,*)DELTAXFLAG
      IF (DELTAXFLAG .EQV. .FALSE.) THEN
      DELTAX= POINTS(I+1,1)-POINTS(I,1)
      DO I=2, NUMPOINTS-2
      IF (((POINTS(I+1,1)-POINTS(I,1)) .LT. DELTAX) .AND. 
     +((POINTS(I+1,1)-POINTS(I,1)) .NE. 0)) THEN
      DELTAX=(POINTS(I+1,1)-POINTS(I,1))
      END IF
      END DO
      
      ELSE
      DELTAX=(XMAX-XMIN)/XSTEP
      
      END IF !--DELTA X FLAG IF
      END SUBROUTINE

!------------------------------------------------------------------------ 
C LABELMAKER SUBROUTINE
C BY ANDREW SPATE & ANDREW BISSELL
C GENERAL: GETS THE CORRECT VALUE TO DISPLAY WITHIN ARRAY FOR X AND Y AXIS
C PRECONDITIONS: N/A
C POSTCONDITIONS: CORRECT VALUE IS LOADED WITHIN ARRAY FOR X AND Y AXIS
C WRITTEN 10/18/2021
!------------------------------------------------------------------------            
      SUBROUTINE LABELMAKER()
      YLABEL(1)=YMIN
      DO I=2, 7
      YLABEL(I)=YLABEL(I-1)+YSTEP
      END DO
      
      XLABEL(1)=XMIN
      I=2
      LABELLOOPS=(INT(XSTEP/5)+1)
      DO WHILE (I .LE. LABELLOOPS) !I=2, 5
      XLABEL(I)=XLABEL(I-1)+(5*DELTAX)
      I=I+1
      END DO
      
      END SUBROUTINE
  
!------------------------------------------------------------------------ 
C SEARCH SUBROUTINE
C BY JUSTIN GUNDERSON
C GENERAL: SEARCHES FOR A POINT FROM THE GIVEN DATA
C PRECONDITIONS: N/A
C POSTCONDITIONS: RETURNS A FLAG WHEN A DATA POINT IS FOUND
C WRITTEN 10/22/2021
!------------------------------------------------------------------------        
      SUBROUTINE SEARCH(POINTS, NUMPOINTS)
      INTEGER, INTENT(IN) :: NUMPOINTS     
      REAL, INTENT(OUT), DIMENSION(100,3) :: POINTS

      FOUNDFLAG=.FALSE.
      P=1
      
      DO WHILE ((FOUNDFLAG .EQV. .FALSE.) .AND. (P .LT. NUMPOINTS+1))
      IF ((POINTS(P,1) .GT. SEARCHFIND(1)).AND.(POINTS(P,1) .LE. 
     +SEARCHFIND(2)) .AND. (POINTS(P,3) .EQ. 0) ) THEN
      POINTS(P,3)=1
      FOUNDFLAG=.TRUE.
      FOUNDINDEX=P
      ELSE
      P=P+1
      END IF
      END DO
      P=P+1
      
      END SUBROUTINE
      
!------------------------------------------------------------------------ 
C GRAPHMAPPER SUBROUTINE
C BY ANDREW SPATE, JUSTIN GUNDERSON, ANDREW BISSELL
C GENERAL: USING DATA GIVEN CREATES A GRAPH WITH THE DATA POINTS GRAPHED WITHIN THE X AND Y AXIS
C PRECONDITIONS: SUBRUTINE SEARCH, LABELMAKER, DELTAXFINDER, STAIRMASTER, MINMAX, SORTER MUST BE PRESENT
C POSTCONDITIONS: GRAPHS THE DATA MAP TO AN ARRAY FOR OUTPUTING
C WRITTEN 10/22/2021
!------------------------------------------------------------------------
      SUBROUTINE GRAPHMAPPER(POINTS, NUMPOINTS)
      REAL, INTENT(OUT), DIMENSION(100,3):: POINTS
      INTEGER, INTENT(IN)::NUMPOINTS
      CHARACTER, DIMENSION(-1:69)::YLINE
      INTEGER :: LOOPMAX, U, O, E
      E=1
      U=0
      SEARCHFIND=0
      
68    FORMAT(' ', F11.5,X,70A)
71    FORMAT(' ', 12X, 70A)
69    FORMAT(' ', 6X,6(F11.5,1X))

      WRITE(2,69)(YLABEL(O),O=1,6)
      
      DO WHILE (U .LE. XSTEP)
      ! IF FIRST LINE, CRATE THE +----+ LINE
      IF (U .EQ. 0) THEN
      YLINE='-'
      DO I=1, 66
      IF (MOD(I,12) .EQ. 0) THEN
      YLINE(I)='+'
      END IF   ! END IF FOR LINE + PLOTTER
      END DO ! END DO LINE 1 + PLOTTER
      
C     CREATE X AXIS      
      ELSE  !ANY LINE BUT FIRST
      YLINE=' ' ! INIT TO SPACES
      IF (MOD(U,5) .EQ. 0) THEN  ! TAKE MODULUS TO FIND DIVISABILITY
      YLINE(1)='+' ! IF A TICK/LABEL NEEDED
      ELSE
      YLINE(1)='|' ! ELSE A STRAIGHT LINE FOR THE x AXIS
      END IF
      END IF !END IF LINE COUNTER
      
      !SEARCH SUBROUTINE
C     FIND SEARCH BOUNDS
      SEARCHFIND(1)=(((U*DELTAX)+XMIN)-(DELTAX/2))
      SEARCHFIND(2)=(((U*DELTAX)+XMIN)+(DELTAX/2))
      
      CALL SEARCH(POINTS, NUMPOINTS)
      IF (FOUNDFLAG .EQV. .TRUE.) THEN
      YP=INT(((POINTS(FOUNDINDEX,2)-YMIN)/(YMAX-YMIN))*66)+1     !FIND POINT SCALE
      YLINE(YP)='*'
      DO WHILE(FOUNDFLAG .EQV. .TRUE.)
      CALL SEARCH(POINTS, NUMPOINTS)
      IF (FOUNDFLAG .EQV. .TRUE.) THEN
      YP=INT(((POINTS(FOUNDINDEX,2)-YMIN)/(YMAX-YMIN))*66)+1
      
      IF (YLINE(YP) .EQ. '*') THEN                               !CHECK CURRENT VALUE
      YLINE(YP)='O'
      ELSE
      YLINE(YP)='*'
      END IF !-- YLINE(YP CHECK)
      END IF !FOUNDFLAG #2 -> TRUE
      END DO !END DO FOR FOUND FLAG- LOOKING FOR SECOND POINT
      END IF !END IF FOUNGFLAG TRUE 
      
C     CHECK LINE NUMBER FOR FORMAT STATEMENT USED      
      IF (MOD(U,5) .EQ. 0) THEN  ! TAKE MODULUS TO FIND DIVISABILITY
      WRITE(2,68)XLABEL(E),(YLINE(L),L=1, 68)
      E=E+1
      ELSE
      WRITE(2,71)(YLINE(L),L=1, 68)
      END IF
      U=U+1
      END DO
      
      END SUBROUTINE
      
      END MODULE
!************************************************************************
      
!------------------------------------------------------------------------ 
C MAIN
C THE GRAPHER PROGRAM
C BY ANDREW SPATE, ANDREW BISSELL, JUSTIN GUNDERSON
C GROUP #2
C GENERAL: HOUSES THE MAIN PROGRAM
C PRECONDITIONS: MODULE IO_FILE AND MODULE GRAPHER REQUIRED
C    SUBROUTINES PRESENT IN IO_FILE MODULE:
C		OPEN_MASTER, INPUTFILE, OUTPUTFILE, READ_THE_FILE
C    SUBROUTINES PRESENT IN GRAPHER MODULE:
C       GRAPHER_MASTER, SORTER, MINMAX, STAIRMASTER, DELTAXFINDER, LABELMAKER, SEARCH, GRAPHMAPPER
C POSTCONDITIONS: TAKES AN INPUT FILE OF DATA AND CREATES A GRAPH OF THE DATA AND OUTPUTS IT TO THE OUTPUT FILE. 
C WRITTEN 10/13/2021 - 10/25/2021
!------------------------------------------------------------------------  
      PROGRAM G2P5
      USE IO_FILE
      USE GRAPHER
      IMPLICIT NONE

      REAL, DIMENSION(100,3):: POINTS
      INTEGER :: NUMPOINTS
      LOGICAL :: ALARMSIREN
      LOGICAL :: BADDATA
      LOGICAL :: HEADACHE
      POINTS=0
      ALARMSIREN= .TRUE.
      BADDATA= .FALSE.
      HEADACHE= .FALSE.
      
      CALL OPEN_MASTER(POINTS, NUMPOINTS, ALARMSIREN, BADDATA,HEADACHE)
      IF (HEADACHE .EQV. .TRUE.) THEN
      WRITE(*,*)"YOU GAVE ME MORE POINTS THAN WERE SPECIFIED..."
      WRITE(*,*)"I'LL COMPLETE YOUR GRAPH FOR ONLY THE NUMBER I EXPECT"
      WRITE(*,*)"DON'T LET IT HAPPEN AGAIN."
      END IF
      IF (ALARMSIREN .EQV. .TRUE. .AND. BADDATA .EQV. .FALSE. ) THEN
      CALL GRAPHER_MASTER(POINTS, NUMPOINTS)
      WRITE(*,*)"PROCESSING COMPLETE"
      END IF
      IF (BADDATA .EQV. .TRUE.) THEN
      WRITE(*,*)"DATA ERROR, CHANGE INPUT FILE AND USER AND TRY AGAIN"
      END IF

      CLOSE(1)
      CLOSE(2)
      END PROGRAM
            
 !------------------------------------------------------------------------ 
C PRINTARRAY SUBROUTINE
C BY ANDREW SPATE
C GENERAL: WRITE MATRIX TO SPECIFIED OUTPUT
C PRECONDITIONS: UNIT DESTINATION FOR WRITE STATEMENT, AND MATRIX TO WRITE, ROWS AND COLUMNS TO PRINT
C POSTCONDITIONS: NONE
C WRITTEN 9/27
C REVISED 9/27- PUT MATRIX INTO GENERIC FORM VS SPECIFIC
!------------------------------------------------------------------------      
      SUBROUTINE PRINTARRAY(GENERICassMATRIX, ROWS, COLUMNS)
      INTEGER, INTENT(IN)::ROWS, COLUMNS
      REAL,INTENT(IN),DIMENSION(100,3)::GENERICassMATRIX
      INTEGER I,J
70    FORMAT(' ',10(F6.2,2X))   
      DO I=1,ROWS
      WRITE(2,70)(GENERICassMATRIX(I,J),J=1,COLUMNS)
      END DO
      END SUBROUTINE PRINTARRAY
